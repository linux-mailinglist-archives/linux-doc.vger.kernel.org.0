Return-Path: <linux-doc+bounces-30564-lists+linux-doc=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-doc@lfdr.de
Delivered-To: lists+linux-doc@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [IPv6:2604:1380:45e3:2400::1])
	by mail.lfdr.de (Postfix) with ESMTPS id 1D16F9C5BDD
	for <lists+linux-doc@lfdr.de>; Tue, 12 Nov 2024 16:29:21 +0100 (CET)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id D1190289C29
	for <lists+linux-doc@lfdr.de>; Tue, 12 Nov 2024 15:29:19 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id DCBB7200B84;
	Tue, 12 Nov 2024 15:29:15 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b="Miuy4Ur8"
X-Original-To: linux-doc@vger.kernel.org
Received: from smtp.kernel.org (aws-us-west-2-korg-mail-1.web.codeaurora.org [10.30.226.201])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B665A1FDF9D
	for <linux-doc@vger.kernel.org>; Tue, 12 Nov 2024 15:29:15 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=10.30.226.201
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1731425355; cv=none; b=cSs6qOz6ZjsAMGpJtkuI4cRhQTYCuziWjtmlyuaOyXnlHwRc6YMP7kCe1c4JpOLyZcN/d6Gp94gj9f7dKDq3dzypr8I1hnaV2bIBQPY9ts/vaXmV/zn/TGI3ngMTc3UfjFFn2zqQrnduhZOGvUGhcXnmRZUxK2mZ0O39CS4ZYB8=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1731425355; c=relaxed/simple;
	bh=xwgEyeereLU4eiO1WkIlcVdeRvYjV3004d2zQyIr3OQ=;
	h=Date:Message-ID:From:To:Cc:Subject:In-Reply-To:References:
	 MIME-Version:Content-Type; b=K7quBBoZhq/0WHHVbEftryRRZ6X49EFZna2ef13ADhe6jARMKrMn0dsvD/53KPOl/vRPxSLSskJNPW/RYh+yqZnAKj5qTrUnl7T8oiMYZWoRHOiUfUdQ/DPmOJ6d+L1PYL82XdB8Mg/+jcdx4VMM/cIl4mWJZ/Ax4tEIJSGKWE8=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b=Miuy4Ur8; arc=none smtp.client-ip=10.30.226.201
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 31D90C4CECD;
	Tue, 12 Nov 2024 15:29:15 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=k20201202; t=1731425355;
	bh=xwgEyeereLU4eiO1WkIlcVdeRvYjV3004d2zQyIr3OQ=;
	h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
	b=Miuy4Ur8bq6SMpilsrXijAo0zoGQlC1vL70M9+h4qq4ZIGomHyvH2ZinCi4UW71N+
	 kmCU8/+0iSQNVyFl61inpirRPq0eS3RrH88gAQshzUVERFcRk5tdI5g+Idc3GZnLh0
	 p2NSObNzWJ5rUuLeodCSdwCg+MGZelPQ1Iv15dn9zyN5mvzLAC7ZPBuCJYtxizjHdz
	 0ajxtNmwx59i5gKRxyX+IIUii3rfKIgfqdEMFd3/0UNrUt18oZEOfgOKLsmGUqqPIB
	 bNrLc+oWNiEIJcN5tFPT1Wz3AzZ15vZDsDQvOKsZQvwC6Odq973AHn+k2/Mb+nXN1N
	 A5MtnTcznVDnQ==
Received: from [104.132.45.109] (helo=wait-a-minute.misterjones.org)
	by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	(Exim 4.95)
	(envelope-from <maz@kernel.org>)
	id 1tAspN-00CEd7-2v;
	Tue, 12 Nov 2024 15:29:13 +0000
Date: Tue, 12 Nov 2024 15:29:12 +0000
Message-ID: <874j4ctqrb.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Zhou Wang <wangzhou1@hisilicon.com>
Cc: <tglx@linutronix.de>,
	<linux-arm-kernel@lists.infradead.org>,
	<linux-doc@vger.kernel.org>,
	<wangwudi@hisilicon.com>,
	Nianyao Tang
	<tangnianyao@huawei.com>
Subject: Re: [PATCH v2] irqchip/gicv3-its: Add workaround for hip09 ITS erratum 162100801
In-Reply-To: <20241112090426.1876148-1-wangzhou1@hisilicon.com>
References: <20241112090426.1876148-1-wangzhou1@hisilicon.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/29.4
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
Precedence: bulk
X-Mailing-List: linux-doc@vger.kernel.org
List-Id: <linux-doc.vger.kernel.org>
List-Subscribe: <mailto:linux-doc+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-doc+unsubscribe@vger.kernel.org>
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 104.132.45.109
X-SA-Exim-Rcpt-To: wangzhou1@hisilicon.com, tglx@linutronix.de, linux-arm-kernel@lists.infradead.org, linux-doc@vger.kernel.org, wangwudi@hisilicon.com, tangnianyao@huawei.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false

On Tue, 12 Nov 2024 09:04:26 +0000,
Zhou Wang <wangzhou1@hisilicon.com> wrote:
> 
> When enabling GICv4.1 in hip09, VMAPP will fail to clear some caches
> during unmapping operation, which will cause some vSGIs lost.
> 
> To fix the issue, it needs to send VINVALL command after VMOVP.
> 
> Signed-off-by: Nianyao Tang <tangnianyao@huawei.com>
> Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
> ---
>  Documentation/arch/arm64/silicon-errata.rst |  2 ++
>  arch/arm64/Kconfig                          | 10 +++++++
>  drivers/irqchip/irq-gic-v3-its.c            | 29 +++++++++++++++++++++
>  3 files changed, 41 insertions(+)
> 
> diff --git a/Documentation/arch/arm64/silicon-errata.rst b/Documentation/arch/arm64/silicon-errata.rst
> index 65bfab1b1861..77db10e944f0 100644
> --- a/Documentation/arch/arm64/silicon-errata.rst
> +++ b/Documentation/arch/arm64/silicon-errata.rst
> @@ -258,6 +258,8 @@ stable kernels.
>  | Hisilicon      | Hip{08,09,10,10C| #162001900      | N/A                         |
>  |                | ,11} SMMU PMCG  |                 |                             |
>  +----------------+-----------------+-----------------+-----------------------------+
> +| Hisilicon      | Hip09           | #162100801      | HISILICON_ERRATUM_162100801 |
> ++----------------+-----------------+-----------------+-----------------------------+
>  +----------------+-----------------+-----------------+-----------------------------+
>  | Qualcomm Tech. | Kryo/Falkor v1  | E1003           | QCOM_FALKOR_ERRATUM_1003    |
>  +----------------+-----------------+-----------------+-----------------------------+
> diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
> index 70d7f4f20225..d41cf6bf1458 100644
> --- a/arch/arm64/Kconfig
> +++ b/arch/arm64/Kconfig
> @@ -1232,6 +1232,16 @@ config HISILICON_ERRATUM_161600802
>  
>  	  If unsure, say Y.
>  
> +config HISILICON_ERRATUM_162100801
> +	bool "Hip09 162100801 erratum support"
> +	default y
> +	help
> +	  When enabling GICv4.1 in hip09, VMAPP will fail to clear some caches
> +	  during unmapping operation, which will cause some vSGIs lost.
> +	  So fix it by sending VINVALL command after VMOVP.
> +
> +	  If unsure, say Y.
> +
>  config QCOM_FALKOR_ERRATUM_1003
>  	bool "Falkor E1003: Incorrect translation due to ASID change"
>  	default y
> diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
> index 52f625e07658..e98d13d0adf9 100644
> --- a/drivers/irqchip/irq-gic-v3-its.c
> +++ b/drivers/irqchip/irq-gic-v3-its.c
> @@ -44,6 +44,7 @@
>  #define ITS_FLAGS_WORKAROUND_CAVIUM_22375	(1ULL << 1)
>  #define ITS_FLAGS_WORKAROUND_CAVIUM_23144	(1ULL << 2)
>  #define ITS_FLAGS_FORCE_NON_SHAREABLE		(1ULL << 3)
> +#define ITS_FLAGS_WORKAROUND_HISILICON_162100801	(1ULL << 4)
>  
>  #define RD_LOCAL_LPI_ENABLED                    BIT(0)
>  #define RD_LOCAL_PENDTABLE_PREALLOCATED         BIT(1)
> @@ -3804,6 +3805,7 @@ static int its_vpe_set_affinity(struct irq_data *d,
>  	struct its_vpe *vpe = irq_data_get_irq_chip_data(d);
>  	unsigned int from, cpu = nr_cpu_ids;
>  	struct cpumask *table_mask;
> +	struct its_node *its;
>  	unsigned long flags;
>  
>  	/*
> @@ -3866,6 +3868,17 @@ static int its_vpe_set_affinity(struct irq_data *d,
>  	vpe->col_idx = cpu;
>  
>  	its_send_vmovp(vpe);
> +
> +	/*
> +	 * Version of ITS is same in one system. As there is no cache in ITS,
> +	 * and only cache in related GICR should be clean, so one VINVALL is
> +	 * enough here.
> +	 */
> +	its = list_first_entry(&its_nodes, struct its_node, entry);
> +	if ((its->flags & ITS_FLAGS_WORKAROUND_HISILICON_162100801) &&
> +	    is_v4_1(its))
> +		its_send_vinvall(its, vpe);

Can this be done using the GICR_INVALLR register instead? I would
expect it to be a bit better performance wise, as it doesn't require
to take a global lock. Something like the hack below (untested).

Thanks,

	M.

diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index fdec478ba5e7..d30d6ee727c1 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -62,6 +62,8 @@ static u32 lpi_id_bits;
 
 static u8 __ro_after_init lpi_prop_prio;
 
+static struct its_node *find_4_1_its(void);
+
 /*
  * Collection structure - just an ID, and a redistributor address to
  * ping. We use one per CPU as a bag of interrupts assigned to this
@@ -3797,6 +3799,22 @@ static void its_vpe_db_proxy_move(struct its_vpe *vpe, int from, int to)
 	raw_spin_unlock_irqrestore(&vpe_proxy.lock, flags);
 }
 
+static void its_vpe_4_1_invall_locked(int cpu, struct its_vpe *vpe)
+{
+	void __iomem *rdbase;
+	u64 val;
+
+	val  = GICR_INVALLR_V;
+	val |= FIELD_PREP(GICR_INVALLR_VPEID, vpe->vpe_id);
+
+	raw_spin_lock(&gic_data_rdist_cpu(cpu)->rd_lock);
+	rdbase = per_cpu_ptr(gic_rdists->rdist, cpu)->rd_base;
+	gic_write_lpir(val, rdbase + GICR_INVALLR);
+
+	wait_for_syncr(rdbase);
+	raw_spin_unlock(&gic_data_rdist_cpu(cpu)->rd_lock);
+}
+
 static int its_vpe_set_affinity(struct irq_data *d,
 				const struct cpumask *mask_val,
 				bool force)
@@ -3849,6 +3867,10 @@ static int its_vpe_set_affinity(struct irq_data *d,
 	vpe->col_idx = cpu;
 
 	its_send_vmovp(vpe);
+
+	if (find_4_1_its()->flags & ITS_FLAGS_WORKAROUND_HISILICON_162100801)
+		its_vpe_4_1_invall_locked(cpu, vpe);
+
 	its_vpe_db_proxy_move(vpe, from, cpu);
 
 out:
@@ -4156,22 +4178,12 @@ static void its_vpe_4_1_deschedule(struct its_vpe *vpe,
 
 static void its_vpe_4_1_invall(struct its_vpe *vpe)
 {
-	void __iomem *rdbase;
 	unsigned long flags;
-	u64 val;
 	int cpu;
 
-	val  = GICR_INVALLR_V;
-	val |= FIELD_PREP(GICR_INVALLR_VPEID, vpe->vpe_id);
-
 	/* Target the redistributor this vPE is currently known on */
 	cpu = vpe_to_cpuid_lock(vpe, &flags);
-	raw_spin_lock(&gic_data_rdist_cpu(cpu)->rd_lock);
-	rdbase = per_cpu_ptr(gic_rdists->rdist, cpu)->rd_base;
-	gic_write_lpir(val, rdbase + GICR_INVALLR);
-
-	wait_for_syncr(rdbase);
-	raw_spin_unlock(&gic_data_rdist_cpu(cpu)->rd_lock);
+	its_vpe_4_1_invall_locked(cpu, vpe);
 	vpe_to_cpuid_unlock(vpe, flags);
 }
 

-- 
Without deviation from the norm, progress is not possible.

